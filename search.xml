<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql</title>
      <link href="/2019/08/14/Mysql/"/>
      <url>/2019/08/14/Mysql/</url>
      
        <content type="html"><![CDATA[<p>#Mysql</p><h2 id="Mysql并发控制"><a href="#Mysql并发控制" class="headerlink" title="Mysql并发控制"></a>Mysql并发控制</h2><p> &nbsp; &nbsp;假设表中的一行记录，在高并发的情况下，一个在读，另一个试图修改，有可能读的会报错退出，也有可能读到错误的数据，因此需要加锁，解决此问题的经典方法就是读写锁。<br> &nbsp;&nbsp;读写锁就是含有两把锁，通常被称为共享锁和排他锁,也叫读锁和写锁。读锁是共享的，读的过程互相不阻塞，而写锁是排他的，在写的过程中会阻塞其他写锁和读锁。</p><p>##锁粒度<br> &nbsp;&nbsp;加锁的范围尽量只锁定想要锁定的部分数据。因为加锁的数据越小，争锁的几率就越小，系统的并发性就越高。<br> &nbsp;&nbsp;加锁本身就是一个耗费资源的操作，包括获得锁，检查锁，释放锁都会增加系统开销，因此说策略，无非就是在资源开销和数据安全性中寻找一个tradeoff。Mysql提供以下两种锁。</p><ul><li>表锁<br>它会锁定整张表，当在对表进行写操作前，需要先拿到写锁然后阻塞其他用户对该表的所有读写操作，只有没有写锁时，其他读取的用户才能拿到读锁。</li><li>行级锁<br>行级锁可以最大程度的支持并发处理，在InnoDB和XtrDB中实现了行级锁。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个操作系统-总线</title>
      <link href="/2019/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%80%BB%E7%BA%BF/"/>
      <url>/2019/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="cpu总线类型"><a href="#cpu总线类型" class="headerlink" title="cpu总线类型"></a>cpu总线类型</h1><p>cpu中按照总线(传输信息)的功能分类,可以分为传递数据信息的数据总线,传递控制信息的控制总线和传递地址信息的地址总线</p><ul><li>数据总线: 数据总线是CPU与存储器,cpu与IO接口设备传送信息的总线,这些总线往返于CPU与存储器,cpu与io接口之间,因此数据总线的数据是双向的</li><li>地址总线:cpu向存储器,io设备传送地址信息,寻址能力是cpu特有的功能,地址总线上的地址信息只能由CPU发送,因此地址总线上的数据是单向的.</li><li>控制总线:控制总线上传递的是各种传递信号,由CPU至存储器,I/O接口向CPU的应答信号,请求信号,因此控制总线是双向的.</li></ul><p>例如向内存中写数据是通过内存总线进行的,数据信息通过数据总线传递至内存中,通过地址总线写到内存的某个单元,什么时候开始写由控制总线获得的控制信号决定.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个操作系统知识-僵死和孤儿进程</title>
      <link href="/2019/08/12/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86-%E5%83%B5%E6%AD%BB%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
      <url>/2019/08/12/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86-%E5%83%B5%E6%AD%BB%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们知道，linux中父进程通过fork和exec来创建并运行子线程，由于linux存在一个机制，就是父进程只要想要拿到子进程的结束时的信息就可以得到，因此每个子进程退出的时候，内核释放进程持有的所有资源，包括打开的文件，占用的内存等，但是仍然会保留一定的信息(包括进程号)供父进程调用，父进程通过调用wait或waitpid方法来释放这一部分资源，如果父进程迟迟不调用的话，这种子线程就叫僵死线程，当有大量的僵死线程的话会占用大量的进程号，由于进程号是有限的很可能会造成其他的进程不能被创建。</p><ul><li>僵死线程:由以上分析可知，僵死线程为父进程没有调用wait或waitpid方法导致的。</li><li>孤儿线程: 孤儿线程就是子进程还在，父进程没了就成孤儿进程了，孤儿进程会被init进程托管，并由init进程对它门完成状态收集工作，问题不大。</li></ul><h2 id="僵死线程很容易造成进程号的大量占用，那么该如何处理这种问题呢"><a href="#僵死线程很容易造成进程号的大量占用，那么该如何处理这种问题呢" class="headerlink" title="僵死线程很容易造成进程号的大量占用，那么该如何处理这种问题呢?"></a>僵死线程很容易造成进程号的大量占用，那么该如何处理这种问题呢?</h2><p>产生这种线程的原因一般都是父线程只管创建子线程，但是不调用wait或waitpid方法来处理，一般情况下是找到这个父线程，然后kill掉，这样这些僵死线程就变成孤儿线程了，这样的话init线程就能回收。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个linux命令-管道</title>
      <link href="/2019/08/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4-%E7%AE%A1%E9%81%93/"/>
      <url>/2019/08/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4-%E7%AE%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;经常被问到进程间是怎么通信的?常见的有socket，管道，消息队列，共享内存等。以后会专门写一个总结一下，这次研究一下管道是什么?<br> &nbsp;&nbsp;一般遇到这种名词的话一般都会想这个是用来解决什么问题了，又是怎么解决的。  </p><ul><li><p>解决了什么问题?<br>&nbsp;&nbsp;* 前面提到了解决了进程间通信的问题,比如一个很简单的例子，想要在nohup.out中搜索某个关键字，cat nohup.out | grep “key” cat是一个进程，grep也是一个进程，它们是怎么通信的。<br>&nbsp;* 怎么解决的?<br>&nbsp;&nbsp;&nbsp;* 上面命令中的 | 就相当于在两个进程之间建立了一个管道(是一个虚拟的文件，是由内存管理的一个缓冲区)，一头对应着一个进程的输出端，一头对应着另一个进程的输入端，上面的例子就是将cat命令的输出作为grep的输入。  </p><p>&nbsp;&nbsp;linux的进程都有独立的地址，因此在用户态进程之间是没法访问的。而内核是进程共享的，因此线程想要通信就要内核做个中间人。<br><img src="https://lovexl-1254108494.cos.ap-chengdu.myqcloud.com/%E5%86%85%E6%A0%B8%E7%AE%A1%E9%81%931.jpg" alt="avatar"><br>&nbsp;&nbsp;pipe的实现和图示一样，在pipefs文件中有一个属性  </p><blockquote><p>struct pipe_inode_info    *i_pipe; <br></p></blockquote><p>&nbsp;&nbsp;pipe_inode_info定义如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> pipe_fs_i.h</span><br><span class="line"> struct pipe_inode_info &#123;</span><br><span class="line">struct mutex mutex;</span><br><span class="line">wait_queue_head_t wait;</span><br><span class="line">unsigned int nrbufs, curbuf, buffers;</span><br><span class="line">unsigned int readers;</span><br><span class="line">unsigned int writers;</span><br><span class="line">unsigned int files;</span><br><span class="line">unsigned int waiting_writers;</span><br><span class="line">unsigned int r_counter;</span><br><span class="line">unsigned int w_counter;</span><br><span class="line">struct page *tmp_page;</span><br><span class="line">struct fasync_struct *fasync_readers;</span><br><span class="line">struct fasync_struct *fasync_writers;</span><br><span class="line">struct pipe_buffer *bufs;</span><br><span class="line">struct user_struct *user;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2019/08/10/linux/"/>
      <url>/2019/08/10/linux/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2019/08/10/ThreadLocal-md/"/>
      <url>/2019/08/10/ThreadLocal-md/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><p>该类提供了线程局部变量。这些变量不同于它们的普通对应物，因为访问某个变量(通过get或者set)的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal实例通常是类中的private static字段，它们希望将状态与某一个线程相关联。</p><h2 id="与线程同步机制的区别"><a href="#与线程同步机制的区别" class="headerlink" title="与线程同步机制的区别"></a>与线程同步机制的区别</h2><p>线程同步机制是多个线程共享一个变量，而ThreadLocal是为每一个线程创建一个单独的变量副本。每个线程都可以独立的改变自己的副本而不影响别人。为多线程环境下变量问题提供了另外一种解决思路。</p><p>ThreadLocal定义了四个方法:</p><ul><li>get(): 返回此线程局部变量的当前线程副本中的值</li><li>initialValue(): 返回此线程局部变量的当前线程的“初始值”</li><li>remove(): 删除当前线程局部变量当前线程的值</li><li>set(T value): 将此线程局部变量的当前线程副本中的值设置为指定值</li></ul><p>除了以上的，ThreadLocal内部还有一个静态内部类ThreadLocalMap，get(),set(),remove()都是基于该内部操作。ThreadLocalMap提供了一种键值对方式存储每一个线程的变量副本的方法，key为当前ThreadLocal对象，value则是对应线程的变量副本。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
